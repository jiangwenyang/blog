<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jiangwenyang.com</id>
    <title>Jiang Wenyang's Blog</title>
    <updated>2022-03-28T05:19:04.976Z</updated>
    <generator>Feed for Node.js</generator>
    <author>
        <name>Jiang Wenyang</name>
        <email>u19950930@gmail.com</email>
        <uri>https://jiangwenyang.com</uri>
    </author>
    <link rel="alternate" href="https://jiangwenyang.com"/>
    <link rel="self" href="https://jiangwenyang.com/atom"/>
    <subtitle>Jiang Wenyang's Blog</subtitle>
    <logo>https://jiangwenyang.com/logo.svg</logo>
    <icon>https://jiangwenyang.com/favicon.ico</icon>
    <rights>All rights reserved 2022, Jiang Wenyang</rights>
    <entry>
        <title type="html"><![CDATA[一个真实的Vue CLI项目迁移到vite]]></title>
        <id>https://jiangwenyang.com/posts/一个真实的vue-cli项目迁移到vite</id>
        <link href="https://jiangwenyang.com/posts/一个真实的vue-cli项目迁移到vite"/>
        <updated>2021-09-22T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[
## 是谁？叫什么？来自哪里？要去往那里？

先来回答灵魂拷问。我们原有的项目是一个使用 Vue CLI 生成的 vue2 项目，项目整体上是没有什么大问题的，但是随着模块的不断增多，Vue CLI 基于 Webpack 构建速度越来越慢，开发体验上比较差，为了减少抓狂时间，我们将目光转向了号称很快的 Vite。

废话不多说，先来看原本的项目结构：

```
├── .browserslistrc
├── .editorconfig
├── .env.development // 环境变量，以下几个文件同
├── .env.development.local
├── .env.pre
├── .env.production
├── .env.si
├── .env.test
├── .eslintignore
├── .eslintrc.js
├── .gitignore
├── .npmrc
├── .nvmrc
├── .prettierignore
├── .prettierrc.js
├── .stylelintignore
├── .stylelintrc.js
├── README.md
├── babel.config.js
├── build/
├── config/ 一些项目配置文件，如代理配置等
├── dist/ 构建产物
├── doc/ 开发文档
├── jsconfig.json
├── mock/
├── package.json
├── postcss.config.js
├── public/
├── src/ 业务相关
├── tests/
├── vue.config.js // Vue CLI配置
└── yarn.lock
```

## 好好的为什么要迁移？

迁移的目的主要是构建速度上的差别，除此之外 Vite 也有一些其他的优势。

- 构建速度

  Vite 相比 Vue CLI 最显著的优势应该就是构建速度了，Vite 基于 esbuild 预构建依赖，因此会快很多，开发体验会更好。

  > Vite 的开发环境和生产环境构建目前有所区别，开发环境因为直接使用原生 ESM 不需要打包，而生产环境打包采用了 Rollup

- 隐藏技术细节

  呃，这一点，其实 vite 和 Vue CLI 没有太大区别。。。

- 折腾，尝试新的工具

  毕竟是新的工具，尝试一下，并且 Vue 社区目前也是在推动的。

## 千里之行始于足下

万事开头难，既然迁移的 Flag 已经立了，只能硬着头皮上了。让我们先简单看一遍 Vite 的官方文档，文档延续了 Vue 官方文档简洁清晰的优点，基本上简单看一遍就对 Vite 比较了解了，具体细节不比过分深究。看完文档很容易发现和 Vue CLI 的一些约定上的区别，对于这部分是必须修改代码的，下面开始迁移

### 首先丢掉历史包袱，移除 Vue CLI 轻装上阵

首先，我们先移除所有和 Vue CLI 相关的依赖以及配置

- 在 `package.json` 的依赖中搜索 `vue-cli` 关键词，然后移除相关依赖。

- 将 script 中的启动脚本改为 Vite 对应的启动脚本

  将原本的启动脚本

  ```json
  {
    "scripts": {
      "dev": "vue-cli-service serve --open",
      "build": "vue-cli-service build --mode development"
    }
  }
  ```

  改为

  ```json
  {
    "scripts": {
      "dev": "vite",
      "build": "vite build",
      "serve": "vite preview"
    }
  }
  ```

### 然后剔个牙，做些“小改动”

我们上面说到 Vite 和 Vue CLI 在部分约定上的不同，需要对代码做一些小改动

#### 入口不同

Vue CLI 默认入口为`src/main.js`，而 Vite 的默认入口则是 index.html

直接引用官方文档：

> Vite 将 `index.html` 视为源码和模块图的一部分。Vite 解析 `<script type="module" src="...">` ，这个标签指向你的 JavaScript 源码。甚至内联引入 JavaScript 的 `<script type="module">` 和引用 CSS 的 `<link href>` 也能利用 Vite 特有的功能被解析。另外，`index.html` 中的 URL 将被自动转换，因此不再需要 `%PUBLIC_URL%` 占位符了。

因此我们首先需要修改原有的入口

将 `public/index.html`

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="renderer" content="webkit" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"
    />
    <meta name="description" content="" />
    <meta name="Keywords" content="" />
    <link rel="icon" href="<%= BASE_URL %>favicon.ico" />
    <title><%= webpackConfig.name %></title>
  </head>
  <body>
    <noscript>
      <strong>本页面需要浏览器支持（启用）JavaScript！！！</strong>
    </noscript>
    <div id="app"></div>
    <!-- built files will be auto injected -->
  </body>
</html>
```

移动到根目录下`index.html` ，并做修改

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="renderer" content="webkit" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"
    />
    <meta name="description" content="" />
    <meta name="Keywords" content="" />
    <link rel="icon" href="./favicon.ico" />
    <title>XXX</title>
  </head>
  <body>
    <noscript>
      <strong>本页面需要浏览器支持（启用）JavaScript！！！</strong>
    </noscript>
    <div id="app"></div>
    <!-- Vite将自动解析下面的js文件 -->
    <script type="module" src="/src/main.js"></script>
  </body>
</html>
```

#### 环境变量不同

Vue CLI 的环境变量和 Vite 的环境变量加载都是通过 [dotenv](https://github.com/motdotla/dotenv) 来实现的，因此在文件命名约定上是一致的。但具有以下两点不同：

- 暴露方式

  - Vue CLI 中约定只有 `NODE_ENV`、`BASE_URL` 和以`VUE_APP_` 开头的变量被暴露出来。

  - Vite 中则约定可以访问 `MODE` （应用运行的模式 development|production） 、`BASE_URL` 、`PROD` （是否运行在生产环境）、`DEV` （是否运行在开发环境）以及以 `VITE_` 开头的环境变量。

- 访问方式

  - Vue CLI 通过`process.env` 来访问

  - Vite 通过 `import.meta.env` 来访问

由于以上的两点不同，迁移时我们就需要：

- 将原本以 `VUE_APP_` 开头的环境变量统一替换为以 `VITE_` 开头；或者可通过修改配置文件 `vite.config.js` 的 [envPrefix](https://cn.vitejs.dev/config/index.html#envprefix) 进行配置，直接配置为 `VUE_APP_` 则不需要对原有环境变量名称进行修改。(配置文件的创建下面将会提到)
- 将 `process.env` 统一替换为 `import.meta.env`。

#### 不能忽略自定义导入类型扩展名（如`.vue`）

在 Vue CLI 中，默认我们可以不写`.vue`扩展名进行导入

```js
import App from "./App";
```

但是在 Vite 中，**不建议**（实测还是可以配置的）忽略自定义扩展名，因为会影响 IDE 和类型支持。因此需要完整书写

```js
import App from "./App.vue";
```

> 非自定义类型的扩展名可以通过配置项 ` resolve.extensions` 来进行配置，默认为 `['.mjs', '.js', '.ts', '.jsx', '.tsx', '.json']`

### 出来吧你，Vite

到目前为止，基本的修改以及完成，我们开始引入 Vite。

Vite 的安装比较简单，唯一需要注意的就是对于不同的 Vue 版本，需要用到不同的插件。

安装 Vite

```bash
$ yarn add -D
```

安装对应版本的 Vue 插件

> Vite 为 Vue 提供第一优先级支持：
>
> - Vue 3 单文件组件支持：[@vitejs/plugin-vue](https://github.com/vitejs/vite/tree/main/packages/plugin-vue)
> - Vue 3 JSX 支持：[@vitejs/plugin-vue-jsx](https://github.com/vitejs/vite/tree/main/packages/plugin-vue-jsx)
> - Vue 2 支持：[underfin/vite-plugin-vue2](https://github.com/underfin/vite-plugin-vue2)

由于我们使用 Vue2，因此安装 `vite-plugin-vue2`

```bash
$ yarn add -D vite-plugin-vue2
```

在根目录创建配置文件 `vite.config.js`

```json
import { defineConfig } from 'vite'
const { createVuePlugin } = require('vite-plugin-vue2')

// https://vitejs.dev/config/
export default defineConfig(() => {
  return {
    base: './',
    clearScreen: false,
    plugins: [createVuePlugin()],
    build: {
      target: 'es2015',
    },
  }
})
```

**完结撒花！！！**

如果你的项目没有其他特殊的需求的话，到目前为止，你基本上应该可以跑起来了。不过，我们的项目就没这么幸运了，旅途才刚刚开始。。。

## 填坑之旅

### 启用 JSX

Vite 默认是不启用 JSX 的，如果要开启 JSX 支持还是比较麻烦的，需要：

1. 实例化 Vue2 插件的时候传入`{jsx: true}` 开启 JSX 支持。

   ```js
   export default defineConfig(() => {
     return {
       plugins: [createVuePlugin({ jsx: true })], // 引入Vue2插件并开启JSX支持
     };
   });
   ```

2. 在用到的组件上加上 `jsx` 标识

   ```js
   <script lang="jsx">
       export default {
           render(){
               return <div>JSX Render</div>
           }
       }
   </script>
   ```

3. 如果是 js 文件，用到了 `jsx` 语法，则需要将后缀名改完 `.jsx` 。

### alias

在原项目中我们在 `vue.config.js` 中 定义了使用了 Webpack 的 `resolve.alias` 特性：

```js
{
	"configureWebpack":{
		resolve: {
      alias: {
        '@': resolve('src'),
        '@api': resolve('src/api'),
        '@components': resolve('src/components'),
        '@containers': resolve('src/containers'),
        '@services': resolve('src/services'),
        '@styles': resolve('src/styles'),
        '@utils': resolve('src/utils'),

        '@@containers': resolve(
          'node_modules/web-lib/packages/web-lib-containers/lib'
        ),
        '@@components': resolve(
          'node_modules/web-lib/packages/web-lib-components/lib'
        ),
        '@@services': resolve(
          'node_modules/web-lib/packages/web-lib-services/lib'
        ),
        '@@utils': resolve('node_modules/web-lib/packages/web-lib-utils/lib'),
        '@@styles': resolve('node_modules/web-lib/packages/web-lib-styles/lib'),
      },
    },
	}
}
```

查看 Vite 的配置文档，发现内置支持了 alias，虽然是通过 `@rollup/plugin-alias` 来实现的，但是幸运的是配置方式基本是一致的。

因此在`vite.config.js` 中返回的配置对象中添加对应配置 `resolve.alias` , 直接复制原有配置对象即可。

```js
resolve: {
      alias: {
        '@': resolve('src'),
        '@api': resolve('src/api'),
        '@components': resolve('src/components'),
        '@containers': resolve('src/containers'),
        '@services': resolve('src/services'),
        '@styles': resolve('src/styles'),
        '@utils': resolve('src/utils'),

        '@@containers': resolve(
          'node_modules/web-lib/packages/web-lib-containers/lib'
        ),
        '@@components': resolve(
          'node_modules/web-lib/packages/web-lib-components/lib'
        ),
        '@@services': resolve(
          'node_modules/web-lib/packages/web-lib-services/lib'
        ),
        '@@utils': resolve('node_modules/web-lib/packages/web-lib-utils/lib'),
        '@@styles': resolve('node_modules/web-lib/packages/web-lib-styles/lib'),
      },
}
```

### 客户端代码中不能使用 node 内部模块

Vite 中不对模块兼容做处理，因此一些 Node 的内置模块在客户端代码中将无法找到。如果确实需要用到，则需要替换为对应的浏览器兼容实现。

如 `path` 模块可以换成对应的浏览器兼容实现 `path-browserify` 。

原有代码使用 `path.join` 来拼接路径：

```js
import path from "path";

export function genPath(...paths) {
  return path.join(...paths);
}
```

在 Vite 中则需要修改为对应浏览器兼容实现 `path-browserify`

首先安装 `path-browserify`

```bash
$ yarn add path-browserify
```

然后直接替换引用即可

```js
import path from "path-browserify";

export function genPath(...paths) {
  return path.join(...paths);
}
```

### 全局 CSS 变量

在我们原项目中在`vue.config.js` 中配置引入了 [sass-resources-loader](https://github.com/shakacode/sass-resources-loader) 来实现。

```js
chainWebpack(config) {
	// 引入全局的sass资源
    const oneOfsMap = config.module.rule('scss').oneOfs.store
    oneOfsMap.forEach(item => {
      item
        .use('sass-resources-loader')
        .loader('sass-resources-loader')
        .options({
          resources: [
            './node_modules/web-lib/packages/web-lib-styles/src/variables/index.scss',
            './src/styles/variables.scss',
          ],
        })
        .end()
    })
}
```

在 Vite 中我们可以通过 ` css.preprocessorOptions` 进行配置。

```js
css: {
      preprocessorOptions: {
        scss: {
          additionalData: `@import './node_modules/web-lib/packages/web-lib-styles/src/variables/index.scss';`,
        },
      },
}
```

如果你细心的话可能会发现，我们的原代码中引入了两个 CSS 文件。而迁移后的我们只引入了一个 CSS 文件。原因是在 `./src/styles/variables.scss` 中我们使用了下面的语法导出了 js 变量

```scss
// 导出，供js模块调用
:export {
  bg: $bg;
  text_color: $text_color;
  header_height: $header_height;
  sidebar_width: $sidebar_width;
  header_bg: $header_bg;
  logo_bg: $logo_bg;
  menu_bg: $menu_bg;
  menu_text_color: $menu_text_color;
  menu_active_text_color: $menu_active_text_color;
  menu_hover: $menu_hover;
}
```

在 Vite 中会出现，如果配置了 `additionalData`，将会报错：

```bash
Error: This file is already being loaded.
    ╷
  2 │           @import './src/styles/variables.scss';
    │                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    ╵
    src/styles/variables.scss 2:19  root stylesheet
```

可参考以下 ISSUE:

- https://github.com/vitejs/vite/issues/3283
- https://github.com/nuxt/vite/issues/117

目前我们的解决方式就是不引入，然后在用到的地方手动进行引入规避这个问题，暂时没有特别好的解决方案。

### 动态导入 png 等图片资源

在 Vue CLI 项目中，我们往往需要通过运行时变量来动态确定一些静态资源来进行导入

```js
const iconSrc = require(`./images/${iconName}.png`);
```

上面的代码使用 webpack 的 url-loader 或 url-loader，将被自动处理

Vite 处理图片资源的动态引入会比较麻烦，有以下几种方式：

1. 使用 `import.meta.globEager` glob 引入

   > 这种方式将会全量的引入匹配的图片

   ```js
   const images = import.meta.globEager("./images/*.png"); // 将会直接导入所有匹配的图片
   const iconSrc = iamges[`./images/${iconName}.png`].default;

   if (iamges[`./images/${iconName}.png`]) {
     // TODO
   } else {
     // TODO
   }
   ```

2. 使用 `new URL(url, import.meta.url)` 引入

   > 这种方式如果图片不存在在代码层面无法判断

   ```js
   const iconSrc = new URL(`./images/${iconName}.png`, import.meta.url); // 将返回一个URL实例
   ```

### svg 雪碧图

在原项目中我们使用了 webpack 的 [svg-sprite-loader](https://github.com/JetBrains/svg-sprite-loader) 插件来实现 svg 雪碧图。

```js
chainWebpack(config) {
  // set svg-sprite-loader
    config.module
      .rule('svg')
      .exclude.add(resolve('src/icons'))
      .end()
    config.module
      .rule('icons')
      .test(/\.svg$/)
      .include.add(resolve('src/icons'))
      .end()
      .use('svg-sprite-loader')
      .loader('svg-sprite-loader')
      .options({
        symbolId: 'icon-[name]',
      })
      .end()
}
```

感谢社区，在 Vite 中我们可以使用插件**[ vite-plugin-svg-icons ](https://github.com/anncwb/vite-plugin-svg-icons)** 来进行替换以实现相同的功能。使用方式基本一样，具体使用可以查看相应文档。

> 注意: svg-sprite-loader 需要手动引入 svg 文件，而 vite-plugin-svg-icons 会自动引入。

在 Vite 配置的 `plugins` 选项中引入插件

```js
import viteSvgIcons from 'vite-plugin-svg-icons'

export default defineConfig(({ mode }) => {
 return {
   viteSvgIcons({
        iconDirs: [resolve('src/icons/svg')],
        symbolId: 'icon-[name]',
    }),
 	}
}
```

在 `main.js` 中引入

```js
import "virtual:svg-icons-register";
```

### Glob 导入

在老项目中我们如果使用了 webpack 的 `require.context` 语法，在 Vite 中会报错。对应的，Vite 提供了`import.meta.glob` 和 `import.meta.globEager` 来代替

例如原本的`src/store/index.js` 中动态引入 modules

```js
// 获取模块文件
const getModuleFiles = () => require.context("./modules", true, /\.js$/);
// 获取模块对象表
const getModules = () => {
  const storeFiles = getModuleFiles();

  const modules = storeFiles.keys().reduce((modules, modulePath) => {
    // set './app.js' => 'app'
    const moduleName = modulePath.replace(/^\.\/(.*)\.\w+$/, "$1");
    const value = storeFiles(modulePath);
    modules[moduleName] = value.default;
    return modules;
  }, {});
  return modules;
};

const modules = getModules();
```

在 Vite 中改为

```js
const files = import.meta.globEager("./modules/*.js");

const modules = Object.keys(files).reduce((pre, path) => {
  pre[path.replace(/(\.\/modules\/|\.js)/g, "")] = files[path].default;
  return pre;
}, {});
```

### 热更新

在原本的`src/store/index.js` 中我们通过以下方式开启了 store 的热更新

```js
// 启用模块热更新
if (module.hot) {
  const modulePaths = getModuleFiles().keys();
  module.hot.accept(["./getters", ...[modulePaths]], () => {
    // 获取更新后的模块
    const getters = require("./getters").default;
    const modules = getModules();
    // 加载新模块
    store.hotUpdate({
      getters,
      modules,
    });
  });
}
```

在 Vite 中直接移除即可，不需要额外配置。

### 在 Vite 配置文件中使用环境变量

如果想在 Vite 配置中使用环境变量，是不能使用 `import.meta.env` 来获取的，因为 Vite 是先解析配置文件再解析环境变量的。因此只能通过 [dotenv](https://github.com/motdotla/dotenv) 来手动解析访问。

```js
export default defineConfig(({ mode }) => {
  // 访问通用环境变量
  const { PORT } = require("dotenv").config({ path: `./.env` }).parsed || {};

  // 访问基于运行环境的环境变量
  const {
    VITE_APP_URI_BUSINESS_SERVICE_BASE,
    VITE_APP_URI_FILE_SERVICE_BASE,
    VITE_APP_USER_SOCTET_BASE,
  } = require("dotenv").config({ path: `./.env.${mode}` }).parsed || {};
  return {
    server: {
      port: PORT,
    },
  };
});
```

## 小甜品，来点工程化优化

### husky+lint-staged 实现提交 lint

husky 可以让我们定义各种 git-hooks，以实现在 git 生命周期中注入各种钩子来定义我们的工作流，比如做代码校验或者邮件通知等。lint-staged 则让我们可以只对待提交的代码进行处理。结合两者便能实现在期望的 git 生命周期中触发对新提交代码进行一系列操作。最常见的便是在 git 的 commit 之前（`pre-commit`），对代码进行校验和格式化。

#### 安装及使用

1. 安装 `husky`

   ```bash
   $ yarn add -D husky
   ```

2. 开启 Git hooks

   ```bash
   yarn husky install
   ```

3. 添加安装项目依赖后自动开启 Git hooks

   `package.json`

   ```bash
   {
     "scripts": {
       "prepare": "husky install"
     }
   }
   ```

4. 安装 lint-staged

   ```bash
   $ yarn add -D lint-staged
   ```

5. 配置 lint-staged

   `package.json`

   ```json
   {
     "lint-staged": {
       "**/*.{vue,js}": ["prettier --write", "eslint --fix", "git add"],
       "**/*.{html,vue,css,scss}": [
         "prettier --write",
         "stylelint --allow-empty-input --fix",
         "git add"
       ],
       "**/*.{md,json}": ["prettier --write", "git add"]
     }
   }
   ```

6. 配置 hook 在提交时触发 lint-staged

   ```bash
   $ npx husky add .husky/pre-commit "npx lint-staged"
   ```

7. 将 hook 添加到 git 中

   ```bash
   $ git add .husky/pre-commit
   ```

#### git 支持的钩子及简单介绍

| 钩子类型           | 钩子名称           | 触发时机                                                                                           | 钩子参数                  | 可中止 |
| ]]></summary>
        <author>
            <name>Jiang Wenyang</name>
            <email>u19950930@gmail.com</email>
            <uri>https://jiangwenyang.com</uri>
        </author>
        <contributor>
            <name>Jiang Wenyang</name>
            <email>u19950930@gmail.com</email>
            <uri>https://jiangwenyang.com</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[TypeScript Learning]]></title>
        <id>https://jiangwenyang.com/posts/TypeScript简明指北</id>
        <link href="https://jiangwenyang.com/posts/TypeScript简明指北"/>
        <updated>2019-10-23T00:00:00.000Z</updated>
        <author>
            <name>Jiang Wenyang</name>
            <email>u19950930@gmail.com</email>
            <uri>https://jiangwenyang.com</uri>
        </author>
        <contributor>
            <name>Jiang Wenyang</name>
            <email>u19950930@gmail.com</email>
            <uri>https://jiangwenyang.com</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS中的空白符和换行处理]]></title>
        <id>https://jiangwenyang.com/posts/CSS中的空白符和换行处理</id>
        <link href="https://jiangwenyang.com/posts/CSS中的空白符和换行处理"/>
        <updated>2018-09-11T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[
## CSS 中的空白符和换行处理

CSS 中主要有三个属性用来处理空白符和换行：`white-space` `word-break` `word-wrap` ，长得有点相似，在中文环境下用到的机会不太多，但是每次用到都傻傻分不清楚，下面整理下这几个属性的区别。

### white-space

`white-space` 看名字就知道主要是用来处理空白符的，但是也涉及到换行的问题。

`white-space` 的有下列的值，对应其中的空白符和换行符处理情况：

| 属性              | 空白符                 | 换行符             | 超出是否自动换行 |
| ]]></summary>
        <author>
            <name>Jiang Wenyang</name>
            <email>u19950930@gmail.com</email>
            <uri>https://jiangwenyang.com</uri>
        </author>
        <contributor>
            <name>Jiang Wenyang</name>
            <email>u19950930@gmail.com</email>
            <uri>https://jiangwenyang.com</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[前端自动化测试]]></title>
        <id>https://jiangwenyang.com/posts/前端自动化测试</id>
        <link href="https://jiangwenyang.com/posts/前端自动化测试"/>
        <updated>2018-06-19T10:20:26.000Z</updated>
        <author>
            <name>Jiang Wenyang</name>
            <email>u19950930@gmail.com</email>
            <uri>https://jiangwenyang.com</uri>
        </author>
        <contributor>
            <name>Jiang Wenyang</name>
            <email>u19950930@gmail.com</email>
            <uri>https://jiangwenyang.com</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Stroybook]]></title>
        <id>https://jiangwenyang.com/posts/Stroybook</id>
        <link href="https://jiangwenyang.com/posts/Stroybook"/>
        <updated>2018-03-28T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[
# Stroybook

### 什么是 Storybook?

Stroybook 是一个可视化的 UI 开发环境，通过 Stroybook 你能快速的渲染展示 UI 组件，将 UI 组件与项目隔离，并且通过提供的丰富的插件来提升开发体验。

### 使用 Strorybook

Stroybook 不仅仅可以应用于 React 项目，同时也支持 Vue 和 Angular，由于目前项目使用 React，并且 Storybook 对 React 的支持度更好，因此在此只介绍 Stroybook for React。

#### 1. 安装

安装配置 Storybook 官方提供了两种方式，一种是使用提供的 cli 工具进行快速生成，一种是手动安装配置。推荐自己手动配置安装以熟悉 Storybook。

##### 1.1 快速生成

Stroybook 官方提供了快速生成 Stroybook 项目骨架的命令行工具，这个工具可以在已有项目下使用。
在项目根目录下执行一下命令：

```bash
$ npm i -g @storybook/cli
$ getstorybook
```

上面的命令将会为你快速生成对应你的项目的 storybook。将会安装对应的依赖，在根目录下创建`.storybook`配置目录并生成对应的配置文件，创建`stories`目录并创建默认的`stories`的 demo

##### 1.2 自定义配置

如果不想全局安装命令行工具，并且希望自定义 Stroybook，推荐自定义安装配置 Stroybook。

1. 安装`@storybook/react`

```bash
$ yarn add -D @storybook/react
```

2. 安装 react，react-dom，babel-core

```bash
yarn add react react-dom
yarn add -D babel-core
```

> Storybook 官方没有给出兼容性列表，但实测无法使用 React 0.14

3. 添加 NPM script
   编辑`package.json`，添加启动 Storybook 的 script 字段

```json
{
  "scripts": {
    "storybook": "start-storybook -p 9001 -c .storybook"
  }
}
```

> `-c` 参数后跟配置文件所处目录，不使用`-c`时将默认使用`.storybook`目录下的配置文件`config.js`

#### 2. 配置

> 如果使用快速生成则下面这些配置文件已经帮你生成好了无需再自己配置。

在根目录下创建`.storybook`文件夹，然后在该目录下创建`config.js`文件。
最简单的配置：

```javascript
import { configure } from '@storybook/react';

function loadStories() {
  require('../stories/index.js');
  // You can require as many stories as you need.
}

configure(loadStories, module);
```

上面的配置文件将会使用`stories/index.js`中的 stories，如果你有多个 stories，每次写 stories 的时候需要对应的进行 require，比较繁琐。如果使用 Webpack，可以使用 Webpack 的[require.context](https://webpack.js.org/guides/dependency-management/)语法：

```javascript
import { configure } from '@storybook/react';

function loadStories() {
  const storiesContext = require.context("../src", true, /\.stories\.tsx$/);
  storiesContext.keys().forEach(storiesContext);
  // 将会加载src所有子目录下的以.stories.tsx结尾的模块
  // You can require as many stories as you need.
}

configure(loadStories, module);
```

#### 3. 写 stories

在组件目录下新建对应 stories 文件，例如在 Button 组件目录下新建`stories/Button.stories.tsx`

```javascript
import React from 'react';
import { storiesOf } from '@storybook/react';
import { action } from '@storybook/addon-actions';
import Button from '../ui.desktop.tsx';

storiesOf('Button', module)
  .add('with text', () => (
    <Button onClick={action('clicked')}>Hello Button</Button>
  ))
  .add('with some emoji', () => (
    <Button onClick={action('clicked')}>😀 😎 👍 💯</Button>
  ));
```

然后执行`npm run storybook`或者`yarn storybook`打开[localhost:9001](localhost:9001)将看到类似下面这样的界面
![](http://ow67vzejn.bkt.clouddn.com/18-1-31/1015387.jpg)

#### 4. 使用 addon

Storybook 通过插件的方式使用额外的功能，主要有两种插件：
**Decorators 类装饰器插件**
Decorators 插件又分为两种:

1. Wrapper Components
   就是普通的 react 容器组件，简单的将你需要 story 的组件包裹在其中。

```javascript
const styles = {
  textAlign: 'center',
};
const Center = ({ children }) => (
  <div style={styles}>
    { children }
  </div>
);
```

2. Storybook Decorators
   扩展一个函数作为 storybook decorator。

```javascript
import { storiesOf } from '@storybook/react';
import { action } from '@storybook/addon-actions';

import Button from './button';

const styles = {
  textAlign: 'center',
};
const CenterDecorator = (storyFn) => (
  <div style={styles}>
    { storyFn() }
  </div>
);

storiesOf('Button', module)
  .addDecorator(CenterDecorator)
  .add('with text', () => (
    <Button onClick={action('clicked')}>Hello Button</Button>
  ))
  .add('with some emojies', () => (
    <Button onClick={action('clicked')}>😀 😎 👍 💯</Button>
  ));

```

> 使用`.addDecorator(Decorator)`语法代码更加简洁,如果要使用全局的 Decorator 可以在`config.js`中配置全局的`Decorator`，将会应用到所有的 stories

例如需要居中显示所有的 stories：

```javascript
import * as React from 'react'
import { configure,addDecorator,setAddon } from '@storybook/react';
addDecorator(stories=>(
		<div style={{textAlign: 'center'}}>
		    {stories()}
		</div>
	)
)
```

**Native Addons 原生插件**
原生插件能在包裹 stories 之前提供基于 Storybook 平台的额外特性，例如 storybook-actions 插件。

使用这两种插件前，我们都需要先在`.storybook`目录下新建`addons.js`来注册对应的插件

```typescript
import "@storybook/addon-actions/register";
import "@storybook/addon-links/register";
import "@storybook/addon-notes/register";
```

插件的具体使用配置需要查看插件自己的文档。

#### 5. 自定义 Webpack 配置

当使用 storybook 时，Storybook 将会使用自己默认的 webpack 配置,使用的是 create-react-app 的 webpack 配置，一般而言适用于绝大多数项目。如果想自定义 webpack 有下面几种方式：
**Extend Mode (扩展模式)**
在`.storybook`目录下新建文件`webpack.config.js`，导出一个**object**

```javascript
const path = require('path');

module.exports = {
  module: {
    rules: [
      {
        test: /\.scss$/,
        loaders: ["style-loader", "css-loader", "sass-loader"],
        include: path.resolve(__dirname, '../')
      }
    ]
  }
}
```

扩展模式下可以更改除：

- entry
- output
- js loader with babel

这几项外所有的 webpack 配置项，Storybook 将会将你的自定义配置项作为默认配置的扩展来启动 webpack。

**Full Control Mode (完全控制模式)**
通过导出一个函数，函数接受两个参数 storybookBaseConfig 和 configType，一个是 Storybook 的基础配置对象，一个是当前的环境（'DEVELOPMENT' or 'PRODUCTION'），然后通过修改 storybookBaseConfig 后返回自定义的配置对象达到完全控制的目的。
官方的 DMEO：

```javascript
const path = require('path');

// Export a function. Accept the base config as the only param.
module.exports = (storybookBaseConfig, configType) => {
  // configType has a value of 'DEVELOPMENT' or 'PRODUCTION'
  // You can change the configuration based on that.
  // 'PRODUCTION' is used when building the static version of storybook.

  // Make whatever fine-grained changes you need
  storybookBaseConfig.module.rules.push({
    test: /\.scss$/,
    loaders: ["style-loader", "css-loader", "sass-loader"],
    include: path.resolve(__dirname, '../')
  });

  // Return the altered config
  return storybookBaseConfig;
};
```

尽量不要去更改下面这几项：

- entry
- output
- first loader in the module.loaders (Babel loader for JS)
- all existing plugins

**Full control mode + default （完全控制+默认配置 模式）**
和完全配置模式几乎一样，唯一的区别是导出的函数多了一个参数 defaultConfig，当导出的函数有三个参数时将会使用这种模式。

```javascript
const path = require('path');

module.exports = (baseConfig, env, defaultConfig) => {
  // Extend defaultConfig as you need.

  // For example, add typescript loader:
  defaultConfig.module.rules.push({
    test: /\.(ts|tsx)$/,
    include: path.resolve(__dirname, '../src'),
    loader: require.resolve('ts-loader')
  });
  defaultConfig.resolve.extensions.push('.ts', '.tsx');

  return defaultConfig;
};
```

> 建议使用扩展模式，配置比较简单。如果需要根据不同的环境进行不同的编译配置，使用全控制模式配置。
> Storybook 的基础配置中只包含了 babel-loader 和 md 解析用的 loader，默认配置中配置了例如 css、json、字体文件、媒体文件相关的 loader，可以在 node_modules\@storybook\react\src\server\config 下看到对应的 webpack 配置文件。

#### 6. 注入 script 或 css

如果你的 UI 库依赖全局的 script 或者 css，可以通过 Storybook 提供的注入的方式。

1. 组件预览 iframe 注入
   在`./stroybook`目录下新建`preview-head.html`,里面的 srcipt 或 css 标签将注入到预览区域的 iframe 中，在 stries 加载前被注入。
   例如希望每个 UI 组件使用 reset.css
   在`preview-head.html`中添加

```javascript
<style>
*{
	margin: 0;
	padding: 0;
}
</style>
```

2. Stroybook 平台注入
   在`./stroybook`目录下新建`manager-head.html`,里面的 script 或 css 标签将注入到 Stroybook 平台下，将在 Stroybook React UI 加载前被注入。

### 配置参考

```javascript
import * as React from 'react'
import { configure,addDecorator,setAddon } from '@storybook/react';

/* 导入storybook插件 */
import { setOptions } from '@storybook/addon-options';
import JSXAddon from 'storybook-addon-jsx';
import { withKnobs } from '@storybook/addon-knobs/react';
import { withDocs } from 'storybook-readme';

/* 通用storybook底部md */
import * as Doc_Footer from './Doc_Footer.md';

/* 设置Storybook UI */
setOptions({
  name: 'AnyShare',
  url: 'https://anyshare.eisoo.com',
  goFullScreen: false,
  showLeftPanel: true,
  showDownPanel: true,
  showSearchBox: false,
  downPanelInRight: true,
});

/* 设置使用JSXAddon，在侧边栏显示渲染区域组件对应的JSX */
setAddon(JSXAddon);

withDocs.addFooterDocs(Doc_Footer); // 当使用withDocs时，使用通用底部md

/* 全局story装饰器 */
addDecorator(withKnobs) // 使用addon-knobs装饰器，允许自定义组件参数，具体参数需要在story中定义


/* 加载story */
function loadStories() {
  const storiesContext = require.context("../src", true, /\.stories\.tsx$/);
  storiesContext.keys().forEach(storiesContext);
}
configure(loadStories, module);
```

ShareWebUI/.sotrybook/addon.js ]]></summary>
        <author>
            <name>Jiang Wenyang</name>
            <email>u19950930@gmail.com</email>
            <uri>https://jiangwenyang.com</uri>
        </author>
        <contributor>
            <name>Jiang Wenyang</name>
            <email>u19950930@gmail.com</email>
            <uri>https://jiangwenyang.com</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git-hook]]></title>
        <id>https://jiangwenyang.com/posts/git-hook</id>
        <link href="https://jiangwenyang.com/posts/git-hook"/>
        <updated>2018-03-12T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[
## Git-hook

Git-hook（git 钩子）是 Git 提供的当特定动作如提交、推送等 Git 行为发生时执行的自定义脚本。主要分为客户端脚本和服务器端脚本。

### Git-hook 的安装

其实当初始化一个 Git 项目的时候，hooks 就已经被安装到项目中，只是默认未启用。当执行`git init`的时候，Git 会初始化示例脚本到`.git/hooks`目录中。

如果想启用这些 hooks 非常简单，只需要去掉`.sample`后缀即可启用。示例代码是使用 shell 编写的,但是 git 并没没有显示编写 hooks 使用的语言,任何可执行脚本都可以使用。

> `.git`目录无法加入到版本控制中，因为每次 clone 一个新的仓库的时候都会新生成`.git`目录。
>
> 由于这个特性，因此只能将 hooks 存储到其他目录，通过软链接或者手动拷贝的方式拷贝到`.git/hooks`目录下，但是这样的问题是当更新或新增 hooks 脚本的时候需要重新建立与`.git/hooks`的关系。

### 客户端钩子

客户端钩子主要有提交工作流钩子、电子邮件工作流钩子和其它钩子。

| 钩子类型           | 钩子名称           | 触发时机                                                                                           | 钩子参数                  | 可中止 |
| ]]></summary>
        <author>
            <name>Jiang Wenyang</name>
            <email>u19950930@gmail.com</email>
            <uri>https://jiangwenyang.com</uri>
        </author>
        <contributor>
            <name>Jiang Wenyang</name>
            <email>u19950930@gmail.com</email>
            <uri>https://jiangwenyang.com</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Enzyme官方API一览]]></title>
        <id>https://jiangwenyang.com/posts/Enzyme官方API一览</id>
        <link href="https://jiangwenyang.com/posts/Enzyme官方API一览"/>
        <updated>2017-12-27T00:00:00.000Z</updated>
        <author>
            <name>Jiang Wenyang</name>
            <email>u19950930@gmail.com</email>
            <uri>https://jiangwenyang.com</uri>
        </author>
        <contributor>
            <name>Jiang Wenyang</name>
            <email>u19950930@gmail.com</email>
            <uri>https://jiangwenyang.com</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[断言库Chai-expect-API一览]]></title>
        <id>https://jiangwenyang.com/posts/Chai-expect API一览</id>
        <link href="https://jiangwenyang.com/posts/Chai-expect API一览"/>
        <updated>2017-12-20T00:00:00.000Z</updated>
        <author>
            <name>Jiang Wenyang</name>
            <email>u19950930@gmail.com</email>
            <uri>https://jiangwenyang.com</uri>
        </author>
        <contributor>
            <name>Jiang Wenyang</name>
            <email>u19950930@gmail.com</email>
            <uri>https://jiangwenyang.com</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[React事件绑定]]></title>
        <id>https://jiangwenyang.com/posts/React事件绑定</id>
        <link href="https://jiangwenyang.com/posts/React事件绑定"/>
        <updated>2017-12-20T00:00:00.000Z</updated>
        <author>
            <name>Jiang Wenyang</name>
            <email>u19950930@gmail.com</email>
            <uri>https://jiangwenyang.com</uri>
        </author>
        <contributor>
            <name>Jiang Wenyang</name>
            <email>u19950930@gmail.com</email>
            <uri>https://jiangwenyang.com</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[React高价组件（HOC）]]></title>
        <id>https://jiangwenyang.com/posts/React高价组件（HOC）</id>
        <link href="https://jiangwenyang.com/posts/React高价组件（HOC）"/>
        <updated>2017-12-20T00:00:00.000Z</updated>
        <author>
            <name>Jiang Wenyang</name>
            <email>u19950930@gmail.com</email>
            <uri>https://jiangwenyang.com</uri>
        </author>
        <contributor>
            <name>Jiang Wenyang</name>
            <email>u19950930@gmail.com</email>
            <uri>https://jiangwenyang.com</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[karma+karma-webpack前端单元测试]]></title>
        <id>https://jiangwenyang.com/posts/karma-karma-webpack前端单元测试</id>
        <link href="https://jiangwenyang.com/posts/karma-karma-webpack前端单元测试"/>
        <updated>2017-12-20T00:00:00.000Z</updated>
        <author>
            <name>Jiang Wenyang</name>
            <email>u19950930@gmail.com</email>
            <uri>https://jiangwenyang.com</uri>
        </author>
        <contributor>
            <name>Jiang Wenyang</name>
            <email>u19950930@gmail.com</email>
            <uri>https://jiangwenyang.com</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mongoose官方API一览]]></title>
        <id>https://jiangwenyang.com/posts/Mongoose官方API一览</id>
        <link href="https://jiangwenyang.com/posts/Mongoose官方API一览"/>
        <updated>2017-04-16T11:30:16.000Z</updated>
        <summary type="html"><![CDATA[
## 简单起步

### 一、安装

使用 npm 安装 mongoose，在这之前应该安装配置好 mongoDB，具体安装方法可以参考 MongoDB 官方安装指导。

```shell
npm install mongoose
```

### 二、连接数据库

预连接（mongoose 监听数据库端口，尝试进行连接）到默认的*localhost*的*test*数据库。

```javascript
var mongoose = require("mongoose");
mongoose.connect("mongodb://localhost/test"); //mongoDB的数据库连接都是以mongodb://打头，后面跟数据库路径
```

### 三、判断是否成功连接数据库

前面已经进行数据库的预连接，在数据库开启成功，连接路径没有问题的情况下一般就能正常连接了。

```javascript
var db = mongoose.connection;
db.on(error, console.error.bind(console, "connection error:"));
db.once("open", function (callback) {
  // 连接成功，后续数据库操作都在回调中进行
});
```

### 四、定义模式

模式是 mongoose 的核心，相当于 SQL 的数据表结构，在这里定义文档的键以及对应的值的类型，以及定义文档的实例方法和模型的静态方法。

```javascript
var Schema = mongoose.Schema;
var UserSchema = new Schema({
  name: String,
  age: Number,
});
```

值对应的类型是 SchemaType，可用的有：

- String
- Number
- Date
- Buffer
- Boolean
- Mixed
- ObjectId
- Array

### 五、导出模型

真正能对数据库进行操作的是模型和文档，模型是我们构建文档的类，文档是模型的实例，文档的颗粒度比文档更小。

```javascript
var Model = mongoose.model;
var user = new Model("user", UserSchema);
```

### 六、生成文档

文档相当于 SQL 中的一行，是真正存储在数据库中的数据。

```javascript
var tom = new user({
  name: "tom",
  age: 20,
});
```

### 七、将文档保存到数据库

在上一步我们仍然没有在数据库中保存任何数据，只是生成了文档，但是并没有存入数据库，我们可以使用在文档上*save（）*方法将生成的文档存入数据库。

```javascript
tom.save(function (err, tom) {
  if (err) return console.error(err);
  //进行其他操作
});
```

### 八、查询数据库

查询数据库文档，通过在*model*上使用*find*方法。

```javascript
user.find({ name: "tom" }, function (err, doc) {
  console.log(doc);
});
```

_如果不传入查询条件将会查询所有文档_

]]></summary>
        <author>
            <name>Jiang Wenyang</name>
            <email>u19950930@gmail.com</email>
            <uri>https://jiangwenyang.com</uri>
        </author>
        <contributor>
            <name>Jiang Wenyang</name>
            <email>u19950930@gmail.com</email>
            <uri>https://jiangwenyang.com</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[windows下git ssh配置]]></title>
        <id>https://jiangwenyang.com/posts/git-ssh配置</id>
        <link href="https://jiangwenyang.com/posts/git-ssh配置"/>
        <updated>2016-05-30T18:58:33.000Z</updated>
        <author>
            <name>Jiang Wenyang</name>
            <email>u19950930@gmail.com</email>
            <uri>https://jiangwenyang.com</uri>
        </author>
        <contributor>
            <name>Jiang Wenyang</name>
            <email>u19950930@gmail.com</email>
            <uri>https://jiangwenyang.com</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[MongoDB入门]]></title>
        <id>https://jiangwenyang.com/posts/MongoDB入门</id>
        <link href="https://jiangwenyang.com/posts/MongoDB入门"/>
        <updated>2016-05-13T00:00:00.000Z</updated>
        <author>
            <name>Jiang Wenyang</name>
            <email>u19950930@gmail.com</email>
            <uri>https://jiangwenyang.com</uri>
        </author>
        <contributor>
            <name>Jiang Wenyang</name>
            <email>u19950930@gmail.com</email>
            <uri>https://jiangwenyang.com</uri>
        </contributor>
    </entry>
</feed>